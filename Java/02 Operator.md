# 02. Operator

## 1.증감연산자 ++ --

피연산자에 저장된 값을 1 증가 또는 감소 시킨다. 

피연산자로 정수, 실수 모두 가능하지만 상수는 값을 변경할 수 없으므로 불가능.

대부분의 연산자는 값을 읽어서 연산에 사용할 뿐, 피연산자의 타입이나 값을 변경시키지 않는다. 오직 대입연산자와 증감연산자만 값을 변경한다. 

j = ++i; // 값이 참조되기 전에 증가시킨다.

j = i++; // 값이 참조된 후에 증가시킨다.

증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 문장으로 쓰인 경우에는 전위형, 후위형의 차이가 없다.  

증감연산자의 사용을 최소화하고, 식에 두번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다. 

## 2. 산술연산자

### 2.1 사칙연산자 + - * /

나눗셈 연산에서 나누는 수로 0을 사용할 수 없고,

부동 소수점값인 0.0f나 0.0d로 나누는 것은 가능하나 결과가 무한대이다.

```java
System.out.println(3/0);  // 컴파일은 정상적으로 되지만 실행시 ArithmeticException 발생
System.out.println(3/0.0; // infinity 출력

```

```java
		int a = 1_000_000;
		int b = 2_000_000; 
		
		long c = a * b;
		
		System.out.println(c);  // -1454759936
		//예상과 전혀 다른 값인 -1454759936이 출력되는 이유: int타입과 int타입의 연산결과는 int타입이다.
		//a*b의 결과가 이미 int값(-1454759936)이므로 long형으로 자동 형변환 되어도 값은 변하지 않는다.
		
		//올바른 결과를 얻기 위해서는 다음과 같이 작성해야 한다.
		long c1 = (long)a*b;
		System.out.println(c1);   //2000000000000
		
		
		// 같은 의미의 식이라도 순서에 따라서 다른 결과를 얻을 수 있다.
		int d = 1000000;
		
		int result1 = d * d / d;
		int result2 = d / d * d;
		
		System.out.println(result1);  // -727  : 곱셈연산을 먼저하면 int 범위를 넘어서기 때문에 예상과 다른 결과가 나온다. 
		System.out.println(result2);  // 1000000

	
```

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다. 

문자는 부호없는 정수로 바뀌어 저장되므로 문자의 사칙연산은 정수간의 사칙연산과 동일하다. 

문자에서 숫자0을 빼주면 숫자가 된다.

int형 간의 나눗셈 int / int를 수행하면 결과가 float이나 double이 아닌 int이다.

*논리 연산자는 효율적인 연산을 한다.

OR연산의 경우 한쪽만 참이여도 전체가 참이므로, 한쪽이 참이 나온다면 나머지 부분의 연산은 하지 않는다.

AND연산도 마찬가지로, 한쪽이 거짓이 나온다면 나머지 부분의 연산은 하지 않는다.

### 2.2 비트연산자

<< 연산자

비트 값들을 왼쪽으로 이동시킨 후에 오른쪽의 빈 공간에는 모두 0 으로 채운다.

>>연산자

비트 값들을 오른쪽으로 이동시킨 후에 왼쪽의 빈 공간에는

양수는 모두 0 으로, 음수는 모두 1로 채운다.

'~' 연산자는 피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 변환한다. 

~~ 이렇게 두번쓰면 비트 전환 연산을 2번 적용한 것인데, 값은 원래의 값과 같지만 데이터 타입이 byte에서 int로 바뀐다.
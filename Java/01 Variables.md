# 01.Variables

# 기본형(primitive type)

### 1.논리형  - boolean

기본값: default

boolean 변수는 yes/no, on/off등의 논리구현에 주로 이용된다. 그리고 boolean은 true 또는 false의 값만을 표현하면 되므로 1bit로도 충분하지만, 자바에서 데이터를 다루는 최소 단위가 byte이기 때문에 boolean의 크기는 1byte이다.

### 2. 문자형 - char

단 하나의 문자를 저장할 수 있는 자료형. 

`char ch = 'A';`

문자가 저장된 것 같지만 , 사실은 문자의 유니코드(정수)가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장한다. A의 유니코드 값은 65이므로 ch에는 65가 저장된다.

그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.

`char ch = 65; // 틀린 코드가 아니다.`

어떤 문자의 유니코드를 아는 방법:  char형 변수를 정수형(int)로 형변환 한다.

`int code = (int) ch;`

tab이나 backspace 등의 특수문자를 저장하려면

`char tab = '\t';`

'\t'는 두 문자로 이루어져 있지만 한 문자(탭,tab)를 의미한다.  

[특수문자 다루기](https://www.notion.so/63b71bcb702743e895f3c39ba43d58fd)

char 타입의 크기는 2byte (=16bit).  표현범위: 0 ~ 2^16 -1

char타입은 정수형과 달리 음수를 나타낼 필요가 없으므로 표현 가능한 값의 범위가 다르다.

동일한 크기인 short의 표현범위는 -2^15 ~ 2^15 -1이다.

`char ch= 'A';``

`short s = 65;`

둘다 동일하게 10진수의 정수 65가 저장되지만, 출력해보면 다른 결과가 나온다.

왜냐하면 println()함수는 변수의 타입에 맞게 출력하기 때문이다. 

*인코딩과 디코딩

문자를 코드로 변환하는 것: 문자 인코딩, 

반대로 코드를 문자로 변환하는 것:문자 디코딩

*아스키(ASCII)

128개(2^7)의 문자 집합을 제공하는 7bit 부호.

숫자 0~9, 영문자 A~Z, a~z가 연속적으로 배치되어 있다.

### 3. 정수형 -byte, short, int, long

byte < short < int < long

1       2          4        8(byte)

int가 디폴트이다.

정수값이 작더라도 byte, short보다 int를 쓰는 것이 좋다.

이유:  연산 시에 범위를 넘어서 잘못된 결과를 얻기가 쉽고,

JVM이 피연산자를 4byte로 저장하기 때문에 byte, short의 값을 계산할 때는 변환하는 연산이 수행된다. 그래서 int를 쓰는 것이 효율적이다.

byte,short는 성능보다 저장공간을 절약하는 것이 중요할 때 쓰자.

int의 범위는 대략 +-20억이다. 이를 넘어가는 수는 long으로 다룬다. 

*오버플로우: 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것.

에러는 발생하지 않지만 예상한 결과를 얻지 못하게 된다. 

최대값+1 = 최소값

최소값-1 = 최대값

부호없는 정수는 2진수로 '0000'이 될 때 오버플로우가 발생하고,

부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다. 

### 4. 실수형 - float, double

float : 4byte

double : 8byte (디폴트)

실수형도 정수형처럼 변수의 값이 표현범위의 최대값을 벗어나면 오버플로우가 발생한다.

정수형과 달리 변수의 값은 무한대가 된다.

그리고 정수형에는 없는 언더플로우가 있는데, 언더플로우는 실수형으로 표현할 수 없는 아주 작은 값이 되는 경우이다. 이 때 변수의 값은 0이된다. 

실수형은 오차가 발생할 수도 있다는 단점이 있다. 그래서 실수형은 표현가능 범위 뿐만 아니라 정밀도도 중요하다. (정밀도 float : 7자리, double: 15자리)

float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 값의 범위 때문이 아니라 높은 정밀도가 필요해서이다. 

float이 연산 속도의 향상이나 메모리 절약 측면에선 더 좋다.  

*형변환(캐스팅, casting): 변수나 리터럴의 타입을 다른 타입으로 변환하는 것. 

기본형에서 boolean을 제외한 나머지 타입은 서로 형변환이 가능하다.

그리고 기본형과 참조형간의 형변환은 불가능하다. 

큰 타입에서 작은 타입으로 변환할 때 경우에 따라 값손실이 발생할 수 있다. 

작은 타입에서 큰 타입으로 변환할 때는 빈 저장공간을 0또는 1로 채운다.

보통은 0으로 채우지만, 변환하려는 값이 음수인 경우에는 1로 채운다.(부호를 유지하기 위해)

*자동 형변환

`float f =1234;     // float f = (float)1234;와 같음`

컴파일러가 생략된 형변환을 자동적으로 추가한다.

변수가 저장할 수 있는 범위의 값보다 큰 값을 저장하려는 경우에 명시적으로 형변환을 해주면,

컴파일러는 프로그래머의 실수가 아니라 의도적인 것으로 간주하고 에러를 발생시키지 않는다.

`char ch = (char)1000; // 에러가 발생하지 않는다.`

서로 다른 두 타입간의 덧셈에서는 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시키고 연산을 수행한다. 값손실의 위험을 줄이기 위함이다. 이를 산술 변환이라고 한다. 

byte → short → int → long → float → double

            char→ int

화살표 방향으로 형변환 하는 경우 자동 형변환이 된다. 

반대 방향으로 변환하는 경우는 반드시 형변환 연산자를 써줘야 한다. 

char↔ short 형변환은 두 방향 모두 값 손실이 발생할 수 있으므로 자동 형변환되지 않는다.